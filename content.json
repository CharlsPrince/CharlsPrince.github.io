[{"title":"使用 plugman 创建Cordova插件-iOS为例","date":"2017-06-28T13:59:28.000Z","path":"2017/06/28/使用 plugman 创建Cordova插件-iOS为例/","text":"准备工作 安装 node.js 主要使用了node.js 的包管理工具npm，这个笔者就不详细介绍了，相信作为一个开发者，不管前后端对这个东西都不会说完全不认识。 npm 安装完成了以后可以执行 npm -v 验证下是否安装成功 安装 plugman (全局安装) npm install -g plugman 一般安装完成会出现这样的界面: 安装完可以执行 plugman -v 验证下是否安装成功如安装成功: 到这一步基本准备工作已完成，下面就可以开始开发你的插件了。创建插件1. cd &lt;到你需要存放插件的地方&gt; 为了方便找到和演示，我直接在桌面创建了一个MyPlugins的文件夹, 这一步可以省略，至于为什么，请看第二步就明白了。 2. 执行一下命令创建插件 以 MyPlugin 为例1plugman create --name &lt;pluginName&gt; --plugin_id &lt;pluginID&gt; --plugin_version &lt;version&gt; [--path &lt;directory&gt;] [--variableNAME=VALUE] 12345678参数:pluginName: 插件名字pluginID: 插件id, egg : coolPlugin oversion: 版本, egg : 0.0.1directory:一个绝对或相对路径的目录，该目录将创建插件项目variable NAME=VALUE: 额外的描述，如作者信息和相关描述egg : plugman create --name MyPlugin --plugin_id com.charls.MyPlugin --plugin_version 0.0.1 创建成功以后MyPlugins文件夹下会出现一个MyPlugin的文件夹: 文件结构目录如下: 3. 为插件添加支持平台 cd 到你的插件根目录 执行一下命令: 12plugman platform add --platform_name &lt;platform&gt;egg : plugman platform add --platform_name ios 你会发现这个时候插件的目录发生了变化: .m 文件当然就是你实现功能的原生代码 .js 文件就是开放给前端js调用的接口代码 4. 编写你的插件实现功能打开 MyPlugin.m 文件，编写一下代码； 或者根据你的喜欢写自己的功能，因为单个文件不好编辑，所以你也可以先在一个demo中编辑功能代码并测试功能是否有效。 不过对js开发的类一定要继承CDVPlugin 12345678910111213141516171819202122232425262728293031323334353637383940/********* MyPlugin.m Cordova Plugin Implementation *******/#import &lt;Cordova/CDV.h&gt;@interface MyPlugin : CDVPlugin &#123; // Member variables go here.&#125;- (void)coolMethod:(CDVInvokedUrlCommand*)command;@end@implementation MyPlugin- (void)coolMethod:(CDVInvokedUrlCommand*)command&#123; [self showAlert]; CDVPluginResult* pluginResult = nil; NSString* echo = [command.arguments objectAtIndex:0]; if (echo != nil &amp;&amp; [echo length] &gt; 0) &#123; pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:echo]; &#125; else &#123; pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR]; &#125; [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];&#125;- (void)showAlert &#123; UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;恭喜你，调用插件成功了!&quot; preferredStyle:UIAlertControllerStyleAlert]; UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil]; UIAlertAction *sureAction = [UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:nil]; [alert addAction:cancelAction]; [alert addAction:sureAction]; [self.viewController presentViewController:alert animated:YES completion:nil];&#125;@end 5. 创建package.json文件12plugman createpackagejson &lt;directory&gt;egg: plugman createpackagejson 然后需要你根据提示填写相关的内容，最后生成一个这个插件的描述信息文件。 如图: 最后，输入yes就行了 6. 注意项 基本到了这一步，一个简单的插件已经创建完了, 下面就是验证工作了。 不过，还有些地方应该注意的。 clobbers 中的 target 限制了你如何调用插件 config-file 中的内容会被配置到工程的config.xml中 source-file 指定了插件的路径 使用插件新建或打开一个cordova项目,然后执行: 12cordova plugin add &lt;你的插件(名称\\路径\\git地址)&gt;egg: cordova plugin add /Users/charls/Desktop/MyPlugins/MyPlugin 新增iOS平台 1cordova platform add ios --save 如果不出意外的话: 再看看工程中的plugins目录是否存在这个插件 修改index.html 和 index.js 然后执行:cordova run ios 最后运行效果: Demo地址","raw":"---\ntitle: 使用 plugman 创建Cordova插件-iOS为例\ndate: 2017-06-28 21:59:28\ntags:\n\t\t- 混合开发\n\t\t- Cordova\n\t\t- 自定义插件\n\t\t- iOS\n---\n\n## 准备工作\n1. 安装 [node.js](http://nodejs.cn/) 主要使用了node.js 的包管理工具npm，这个笔者就不详细介绍了，相信作为一个开发者，不管前后端对这个东西都不会说完全不认识。\n\nnpm 安装完成了以后可以执行 `npm -v` 验证下是否安装成功\n![npm 安装成功](http://upload-images.jianshu.io/upload_images/2925367-b9603e835d314770.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2. 安装 plugman (全局安装)\n\n> npm install -g plugman\n\n一般安装完成会出现这样的界面:\n![plugman 安装完成](http://upload-images.jianshu.io/upload_images/2925367-dbb4d5fb943e1379.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n安装完可以执行 `plugman -v` 验证下是否安装成功\n如安装成功: \n\n![plugman 安装成功](http://upload-images.jianshu.io/upload_images/2925367-9efd0c08ff00c125.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### 到这一步基本准备工作已完成，下面就可以开始开发你的插件了。\n\n## 创建插件\n### 1. cd <到你需要存放插件的地方>\n\n 为了方便找到和演示，我直接在桌面创建了一个MyPlugins的文件夹, 这一步可以省略，至于为什么，请看第二步就明白了。\n \n ![插件存放文件夹](http://upload-images.jianshu.io/upload_images/2925367-f16b19b3f191a00f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n \n ### 2. 执行一下命令创建插件\n \n 以 `MyPlugin` 为例\n```\nplugman create --name <pluginName> --plugin_id <pluginID> --plugin_version <version> [--path <directory>] [--variableNAME=VALUE]\n```\n\n```\n参数:\npluginName: 插件名字\npluginID: 插件id, egg : coolPlugin \noversion: 版本, egg : 0.0.1\ndirectory:一个绝对或相对路径的目录，该目录将创建插件项目\nvariable NAME=VALUE: 额外的描述，如作者信息和相关描述\n\negg : plugman create --name MyPlugin --plugin_id com.charls.MyPlugin --plugin_version 0.0.1 \n```\n\n创建成功以后MyPlugins文件夹下会出现一个MyPlugin的文件夹:\n\n![插件创建成功](http://upload-images.jianshu.io/upload_images/2925367-97b40f59672f3e32.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n文件结构目录如下:\n\n![插件文件目录](http://upload-images.jianshu.io/upload_images/2925367-ade221c02ba54734.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 3. 为插件添加支持平台\n- cd 到你的插件根目录\n- 执行一下命令:\n\n```\nplugman platform add --platform_name <platform>\negg : plugman platform add --platform_name ios\n```\n\n你会发现这个时候插件的目录发生了变化:\n\n![添加了支持平台的目录结构](http://upload-images.jianshu.io/upload_images/2925367-5b7701bf5824f71f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- .m 文件当然就是你实现功能的原生代码\n- .js 文件就是开放给前端js调用的接口代码\n\n### 4. 编写你的插件实现功能\n\n打开 MyPlugin.m 文件，编写一下代码；\n\n或者根据你的喜欢写自己的功能，因为单个文件不好编辑，所以你也可以先在一个demo中编辑功能代码并测试功能是否有效。\n\n不过对js开发的类一定要继承`CDVPlugin`\n\n```\n/********* MyPlugin.m Cordova Plugin Implementation *******/\n\n#import <Cordova/CDV.h>\n\n@interface MyPlugin : CDVPlugin {\n  // Member variables go here.\n}\n\n- (void)coolMethod:(CDVInvokedUrlCommand*)command;\n@end\n\n@implementation MyPlugin\n\n- (void)coolMethod:(CDVInvokedUrlCommand*)command\n{\n\n    [self showAlert];\n\n    CDVPluginResult* pluginResult = nil;\n    NSString* echo = [command.arguments objectAtIndex:0];\n\n    if (echo != nil && [echo length] > 0) {\n        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:echo];\n    } else {\n        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR];\n    }\n\n    [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];\n}\n\n- (void)showAlert {\n    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@\"提示\" message:@\"恭喜你，调用插件成功了!\" preferredStyle:UIAlertControllerStyleAlert];\n    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@\"取消\" style:UIAlertActionStyleCancel handler:nil];\n    UIAlertAction *sureAction = [UIAlertAction actionWithTitle:@\"确定\" style:UIAlertActionStyleDefault handler:nil];\n    [alert addAction:cancelAction];\n    [alert addAction:sureAction];\n    [self.viewController presentViewController:alert animated:YES completion:nil];\n}\n\n@end\n```\n\n### 5. 创建package.json文件\n\n```\nplugman createpackagejson <directory>\negg: plugman createpackagejson \n```\n\n然后需要你根据提示填写相关的内容，最后生成一个这个插件的描述信息文件。\n\n如图: 最后，输入`yes`就行了\n\n![创建package.json文件](http://upload-images.jianshu.io/upload_images/2925367-6dd4b341efd6a3e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 6. 注意项\n---\n基本到了这一步，一个简单的插件已经创建完了, 下面就是验证工作了。\n\n不过，还有些地方应该注意的。\n\n![plug.xml](http://upload-images.jianshu.io/upload_images/2925367-d049b9a15572f7fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- `clobbers` 中的 `target` 限制了你如何调用插件\n- `config-file` 中的内容会被配置到工程的`config.xml`中\n- `source-file` 指定了插件的路径\n\n\n## 使用插件\n\n新建或打开一个cordova项目,然后执行:\n\n\n```\ncordova plugin add <你的插件(名称\\路径\\git地址)>\negg: cordova plugin add /Users/charls/Desktop/MyPlugins/MyPlugin\n```\n\n新增iOS平台\n\n```\ncordova platform add ios --save\n```\n\n\n如果不出意外的话:\n\n![插件安装成功](http://upload-images.jianshu.io/upload_images/2925367-90f671cc77e43ee7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n再看看工程中的plugins目录是否存在这个插件\n\n![插件安装成功plugins](http://upload-images.jianshu.io/upload_images/2925367-f3fa5458e6274cec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n修改index.html 和 index.js\n\n![修改index.html](http://upload-images.jianshu.io/upload_images/2925367-4dfcbc3c3fc7c8fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![修改index.js](http://upload-images.jianshu.io/upload_images/2925367-517dbbb270f40ee2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n然后执行:\ncordova run ios\n\n最后运行效果:\n![运行效果](http://upload-images.jianshu.io/upload_images/2925367-65b71ee91749bf77.gif?imageMogr2/auto-orient/strip)\n\n[Demo地址](https://github.com/CharlsPrince/MyPluginsDemo)\n\n","content":"<h2 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h2><ol>\n<li>安装 <a href=\"http://nodejs.cn/\" target=\"_blank\" rel=\"external\">node.js</a> 主要使用了node.js 的包管理工具npm，这个笔者就不详细介绍了，相信作为一个开发者，不管前后端对这个东西都不会说完全不认识。</li>\n</ol>\n<p>npm 安装完成了以后可以执行 <code>npm -v</code> 验证下是否安装成功<br><img src=\"http://upload-images.jianshu.io/upload_images/2925367-b9603e835d314770.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"npm 安装成功\"></p>\n<ol>\n<li>安装 plugman (全局安装)</li>\n</ol>\n<blockquote>\n<p>npm install -g plugman</p>\n</blockquote>\n<p>一般安装完成会出现这样的界面:<br><img src=\"http://upload-images.jianshu.io/upload_images/2925367-dbb4d5fb943e1379.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"plugman 安装完成\"></p>\n<p>安装完可以执行 <code>plugman -v</code> 验证下是否安装成功<br>如安装成功: </p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-9efd0c08ff00c125.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"plugman 安装成功\"></p>\n<h5 id=\"到这一步基本准备工作已完成，下面就可以开始开发你的插件了。\"><a href=\"#到这一步基本准备工作已完成，下面就可以开始开发你的插件了。\" class=\"headerlink\" title=\"到这一步基本准备工作已完成，下面就可以开始开发你的插件了。\"></a>到这一步基本准备工作已完成，下面就可以开始开发你的插件了。</h5><h2 id=\"创建插件\"><a href=\"#创建插件\" class=\"headerlink\" title=\"创建插件\"></a>创建插件</h2><h3 id=\"1-cd-lt-到你需要存放插件的地方-gt\"><a href=\"#1-cd-lt-到你需要存放插件的地方-gt\" class=\"headerlink\" title=\"1. cd &lt;到你需要存放插件的地方&gt;\"></a>1. cd &lt;到你需要存放插件的地方&gt;</h3><p> 为了方便找到和演示，我直接在桌面创建了一个MyPlugins的文件夹, 这一步可以省略，至于为什么，请看第二步就明白了。</p>\n<p> <img src=\"http://upload-images.jianshu.io/upload_images/2925367-f16b19b3f191a00f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"插件存放文件夹\"></p>\n<h3 id=\"2-执行一下命令创建插件\"><a href=\"#2-执行一下命令创建插件\" class=\"headerlink\" title=\"2. 执行一下命令创建插件\"></a>2. 执行一下命令创建插件</h3><p> 以 <code>MyPlugin</code> 为例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugman create --name &lt;pluginName&gt; --plugin_id &lt;pluginID&gt; --plugin_version &lt;version&gt; [--path &lt;directory&gt;] [--variableNAME=VALUE]</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">参数:</div><div class=\"line\">pluginName: 插件名字</div><div class=\"line\">pluginID: 插件id, egg : coolPlugin </div><div class=\"line\">oversion: 版本, egg : 0.0.1</div><div class=\"line\">directory:一个绝对或相对路径的目录，该目录将创建插件项目</div><div class=\"line\">variable NAME=VALUE: 额外的描述，如作者信息和相关描述</div><div class=\"line\"></div><div class=\"line\">egg : plugman create --name MyPlugin --plugin_id com.charls.MyPlugin --plugin_version 0.0.1</div></pre></td></tr></table></figure>\n<p>创建成功以后MyPlugins文件夹下会出现一个MyPlugin的文件夹:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-97b40f59672f3e32.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"插件创建成功\"></p>\n<p>文件结构目录如下:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-ade221c02ba54734.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"插件文件目录\"></p>\n<h3 id=\"3-为插件添加支持平台\"><a href=\"#3-为插件添加支持平台\" class=\"headerlink\" title=\"3. 为插件添加支持平台\"></a>3. 为插件添加支持平台</h3><ul>\n<li>cd 到你的插件根目录</li>\n<li>执行一下命令:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugman platform add --platform_name &lt;platform&gt;</div><div class=\"line\">egg : plugman platform add --platform_name ios</div></pre></td></tr></table></figure>\n<p>你会发现这个时候插件的目录发生了变化:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-5b7701bf5824f71f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"添加了支持平台的目录结构\"></p>\n<ul>\n<li>.m 文件当然就是你实现功能的原生代码</li>\n<li>.js 文件就是开放给前端js调用的接口代码</li>\n</ul>\n<h3 id=\"4-编写你的插件实现功能\"><a href=\"#4-编写你的插件实现功能\" class=\"headerlink\" title=\"4. 编写你的插件实现功能\"></a>4. 编写你的插件实现功能</h3><p>打开 MyPlugin.m 文件，编写一下代码；</p>\n<p>或者根据你的喜欢写自己的功能，因为单个文件不好编辑，所以你也可以先在一个demo中编辑功能代码并测试功能是否有效。</p>\n<p>不过对js开发的类一定要继承<code>CDVPlugin</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">/********* MyPlugin.m Cordova Plugin Implementation *******/</div><div class=\"line\"></div><div class=\"line\">#import &lt;Cordova/CDV.h&gt;</div><div class=\"line\"></div><div class=\"line\">@interface MyPlugin : CDVPlugin &#123;</div><div class=\"line\">  // Member variables go here.</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)coolMethod:(CDVInvokedUrlCommand*)command;</div><div class=\"line\">@end</div><div class=\"line\"></div><div class=\"line\">@implementation MyPlugin</div><div class=\"line\"></div><div class=\"line\">- (void)coolMethod:(CDVInvokedUrlCommand*)command</div><div class=\"line\">&#123;</div><div class=\"line\"></div><div class=\"line\">    [self showAlert];</div><div class=\"line\"></div><div class=\"line\">    CDVPluginResult* pluginResult = nil;</div><div class=\"line\">    NSString* echo = [command.arguments objectAtIndex:0];</div><div class=\"line\"></div><div class=\"line\">    if (echo != nil &amp;&amp; [echo length] &gt; 0) &#123;</div><div class=\"line\">        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_OK messageAsString:echo];</div><div class=\"line\">    &#125; else &#123;</div><div class=\"line\">        pluginResult = [CDVPluginResult resultWithStatus:CDVCommandStatus_ERROR];</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    [self.commandDelegate sendPluginResult:pluginResult callbackId:command.callbackId];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)showAlert &#123;</div><div class=\"line\">    UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;提示&quot; message:@&quot;恭喜你，调用插件成功了!&quot; preferredStyle:UIAlertControllerStyleAlert];</div><div class=\"line\">    UIAlertAction *cancelAction = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleCancel handler:nil];</div><div class=\"line\">    UIAlertAction *sureAction = [UIAlertAction actionWithTitle:@&quot;确定&quot; style:UIAlertActionStyleDefault handler:nil];</div><div class=\"line\">    [alert addAction:cancelAction];</div><div class=\"line\">    [alert addAction:sureAction];</div><div class=\"line\">    [self.viewController presentViewController:alert animated:YES completion:nil];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@end</div></pre></td></tr></table></figure>\n<h3 id=\"5-创建package-json文件\"><a href=\"#5-创建package-json文件\" class=\"headerlink\" title=\"5. 创建package.json文件\"></a>5. 创建package.json文件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">plugman createpackagejson &lt;directory&gt;</div><div class=\"line\">egg: plugman createpackagejson</div></pre></td></tr></table></figure>\n<p>然后需要你根据提示填写相关的内容，最后生成一个这个插件的描述信息文件。</p>\n<p>如图: 最后，输入<code>yes</code>就行了</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-6dd4b341efd6a3e9.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"创建package.json文件\"></p>\n<h3 id=\"6-注意项\"><a href=\"#6-注意项\" class=\"headerlink\" title=\"6. 注意项\"></a>6. 注意项</h3><hr>\n<p>基本到了这一步，一个简单的插件已经创建完了, 下面就是验证工作了。</p>\n<p>不过，还有些地方应该注意的。</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-d049b9a15572f7fc.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"plug.xml\"></p>\n<ul>\n<li><code>clobbers</code> 中的 <code>target</code> 限制了你如何调用插件</li>\n<li><code>config-file</code> 中的内容会被配置到工程的<code>config.xml</code>中</li>\n<li><code>source-file</code> 指定了插件的路径</li>\n</ul>\n<h2 id=\"使用插件\"><a href=\"#使用插件\" class=\"headerlink\" title=\"使用插件\"></a>使用插件</h2><p>新建或打开一个cordova项目,然后执行:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add &lt;你的插件(名称\\路径\\git地址)&gt;</div><div class=\"line\">egg: cordova plugin add /Users/charls/Desktop/MyPlugins/MyPlugin</div></pre></td></tr></table></figure>\n<p>新增iOS平台</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova platform add ios --save</div></pre></td></tr></table></figure>\n<p>如果不出意外的话:</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-90f671cc77e43ee7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"插件安装成功\"></p>\n<p>再看看工程中的plugins目录是否存在这个插件</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-f3fa5458e6274cec.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"插件安装成功plugins\"></p>\n<p>修改index.html 和 index.js</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-4dfcbc3c3fc7c8fd.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改index.html\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-517dbbb270f40ee2.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"修改index.js\"></p>\n<p>然后执行:<br>cordova run ios</p>\n<p>最后运行效果:<br><img src=\"http://upload-images.jianshu.io/upload_images/2925367-65b71ee91749bf77.gif?imageMogr2/auto-orient/strip\" alt=\"运行效果\"></p>\n<p><a href=\"https://github.com/CharlsPrince/MyPluginsDemo\" target=\"_blank\" rel=\"external\">Demo地址</a></p>\n","slug":"使用 plugman 创建Cordova插件-iOS为例","updated":"2017-06-28T14:08:50.000Z","comments":true,"link":"","permalink":"http://charlsPrince.com/2017/06/28/使用 plugman 创建Cordova插件-iOS为例/","excerpt":"","categories":[],"tags":[{"name":"混合开发","slug":"混合开发","permalink":"http://charlsPrince.com/tags/混合开发/"},{"name":"Cordova","slug":"Cordova","permalink":"http://charlsPrince.com/tags/Cordova/"},{"name":"iOS","slug":"iOS","permalink":"http://charlsPrince.com/tags/iOS/"},{"name":"自定义插件","slug":"自定义插件","permalink":"http://charlsPrince.com/tags/自定义插件/"}]},{"title":"Runtime方法交换机制","date":"2017-06-27T03:39:25.000Z","path":"2017/06/27/Runtime方法交换机制/","text":"一、运行时所谓运行时，就是说程序在运行(或者在被执行时)的状态，运行时对于项目编程来说是一个必要重要的机制，能够帮我们处理很多未知的情况，比如说动态创建类、添加属性、方法等。 二、运用领域 在程序运行时，动态创建一个类 在程序运行时，动态为某类添加属性、方法，修改属性值、方法名称 。。。 三、这里简单说一下方法交换机制比如说一个工程里面，你们会使用很多系统控件，比如说UIButton，假设有一个需求说要将所有的button的点击标题颜色改成其他的颜色，难道你要一个一个去修改？估计你会想死的心都有，那怎么办？方法交换机制可以帮到你, 原始代码：12345678UIButton *runTimeButton = [UIButton buttonWithType:UIButtonTypeCustom];[runTimeButton setFrame:CGRectMake(100, 100, 150, 30)];[runTimeButton setTitle:@&quot;button&quot; forState:UIControlStateNormal];[runTimeButton setTitleColor:[UIColor purpleColor] forState:UIControlStateNormal];[runTimeButton setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted];[runTimeButton setBackgroundColor:[UIColor whiteColor]];[runTimeButton addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];[self.view addSubview:runTimeButton]; 只要新建一个UIButton的分类，实现类似下面的代码就可以实现方法的交换，这样你就可以在不改动原始代码的情况下实现所有按钮的标题颜色 新建分类代码：123456789101112+ (void)load &#123; Method setTitleColorMethod = class_getInstanceMethod(self, @selector(setTitleColor:forState:)); Method hyc_setTitleColorMethod = class_getInstanceMethod(self, @selector(hyc_setTitleColor:forState:)); method_exchangeImplementations(setTitleColorMethod, hyc_setTitleColorMethod);&#125;- (void)hyc_setTitleColor:(UIColor *)color forState:(UIControlState)state &#123; [self hyc_setTitleColor:[UIColor yellowColor] forState:state]; if (state == UIControlStateHighlighted) &#123; [self hyc_setTitleColor:[UIColor redColor] forState:state]; &#125;&#125; 看看效果：","raw":"---\ntitle: Runtime方法交换机制\ndate: 2017-06-27 11:39:25\ntags:\n\t\t- iOS\n\t\t- Runtime\n---\n\n### 一、运行时\n所谓运行时，就是说程序在运行(或者在被执行时)的状态，运行时对于项目编程来说是一个必要重要的机制，能够帮我们处理很多未知的情况，比如说动态创建类、添加属性、方法等。\n\n### 二、运用领域\n* 在程序运行时，动态创建一个类\n* 在程序运行时，动态为某类添加属性、方法，修改属性值、方法名称\n* 。。。\n\n### 三、这里简单说一下方法交换机制\n比如说一个工程里面，你们会使用很多系统控件，比如说UIButton，假设有一个需求说要将所有的button的点击标题颜色改成其他的颜色，难道你要一个一个去修改？估计你会想死的心都有，那怎么办？方法交换机制可以帮到你,\n\n#### 原始代码：\n```\n    UIButton *runTimeButton = [UIButton buttonWithType:UIButtonTypeCustom];\n    [runTimeButton setFrame:CGRectMake(100, 100, 150, 30)];\n    [runTimeButton setTitle:@\"button\" forState:UIControlStateNormal];\n    [runTimeButton setTitleColor:[UIColor purpleColor] forState:UIControlStateNormal];\n    [runTimeButton setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted];\n    [runTimeButton setBackgroundColor:[UIColor whiteColor]];\n    [runTimeButton addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];\n    [self.view addSubview:runTimeButton];\n```\n\n只要新建一个UIButton的分类，实现类似下面的代码就可以实现方法的交换，这样你就可以在不改动原始代码的情况下实现所有按钮的标题颜色\n#### 新建分类代码：\n```\n+ (void)load {\n    Method setTitleColorMethod = class_getInstanceMethod(self, @selector(setTitleColor:forState:));\n    Method hyc_setTitleColorMethod = class_getInstanceMethod(self, @selector(hyc_setTitleColor:forState:));\n    method_exchangeImplementations(setTitleColorMethod, hyc_setTitleColorMethod);\n}\n\n- (void)hyc_setTitleColor:(UIColor *)color forState:(UIControlState)state {\n    [self hyc_setTitleColor:[UIColor yellowColor] forState:state];\n    if (state == UIControlStateHighlighted) {\n        [self hyc_setTitleColor:[UIColor redColor] forState:state];\n    }\n}\n```\n\n#### 看看效果：\n![runtime效果.gif](http://upload-images.jianshu.io/upload_images/2925367-ab04505e35a95669.gif?imageMogr2/auto-orient/strip)\n\n\n","content":"<h3 id=\"一、运行时\"><a href=\"#一、运行时\" class=\"headerlink\" title=\"一、运行时\"></a>一、运行时</h3><p>所谓运行时，就是说程序在运行(或者在被执行时)的状态，运行时对于项目编程来说是一个必要重要的机制，能够帮我们处理很多未知的情况，比如说动态创建类、添加属性、方法等。</p>\n<h3 id=\"二、运用领域\"><a href=\"#二、运用领域\" class=\"headerlink\" title=\"二、运用领域\"></a>二、运用领域</h3><ul>\n<li>在程序运行时，动态创建一个类</li>\n<li>在程序运行时，动态为某类添加属性、方法，修改属性值、方法名称</li>\n<li>。。。</li>\n</ul>\n<h3 id=\"三、这里简单说一下方法交换机制\"><a href=\"#三、这里简单说一下方法交换机制\" class=\"headerlink\" title=\"三、这里简单说一下方法交换机制\"></a>三、这里简单说一下方法交换机制</h3><p>比如说一个工程里面，你们会使用很多系统控件，比如说UIButton，假设有一个需求说要将所有的button的点击标题颜色改成其他的颜色，难道你要一个一个去修改？估计你会想死的心都有，那怎么办？方法交换机制可以帮到你,</p>\n<h4 id=\"原始代码：\"><a href=\"#原始代码：\" class=\"headerlink\" title=\"原始代码：\"></a>原始代码：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">UIButton *runTimeButton = [UIButton buttonWithType:UIButtonTypeCustom];</div><div class=\"line\">[runTimeButton setFrame:CGRectMake(100, 100, 150, 30)];</div><div class=\"line\">[runTimeButton setTitle:@&quot;button&quot; forState:UIControlStateNormal];</div><div class=\"line\">[runTimeButton setTitleColor:[UIColor purpleColor] forState:UIControlStateNormal];</div><div class=\"line\">[runTimeButton setTitleColor:[UIColor blueColor] forState:UIControlStateHighlighted];</div><div class=\"line\">[runTimeButton setBackgroundColor:[UIColor whiteColor]];</div><div class=\"line\">[runTimeButton addTarget:self action:@selector(buttonClicked:) forControlEvents:UIControlEventTouchUpInside];</div><div class=\"line\">[self.view addSubview:runTimeButton];</div></pre></td></tr></table></figure>\n<p>只要新建一个UIButton的分类，实现类似下面的代码就可以实现方法的交换，这样你就可以在不改动原始代码的情况下实现所有按钮的标题颜色</p>\n<h4 id=\"新建分类代码：\"><a href=\"#新建分类代码：\" class=\"headerlink\" title=\"新建分类代码：\"></a>新建分类代码：</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">+ (void)load &#123;</div><div class=\"line\">    Method setTitleColorMethod = class_getInstanceMethod(self, @selector(setTitleColor:forState:));</div><div class=\"line\">    Method hyc_setTitleColorMethod = class_getInstanceMethod(self, @selector(hyc_setTitleColor:forState:));</div><div class=\"line\">    method_exchangeImplementations(setTitleColorMethod, hyc_setTitleColorMethod);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">- (void)hyc_setTitleColor:(UIColor *)color forState:(UIControlState)state &#123;</div><div class=\"line\">    [self hyc_setTitleColor:[UIColor yellowColor] forState:state];</div><div class=\"line\">    if (state == UIControlStateHighlighted) &#123;</div><div class=\"line\">        [self hyc_setTitleColor:[UIColor redColor] forState:state];</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h4 id=\"看看效果：\"><a href=\"#看看效果：\" class=\"headerlink\" title=\"看看效果：\"></a>看看效果：</h4><p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-ab04505e35a95669.gif?imageMogr2/auto-orient/strip\" alt=\"runtime效果.gif\"></p>\n","slug":"Runtime方法交换机制","updated":"2017-06-27T05:06:50.000Z","comments":true,"link":"","permalink":"http://charlsPrince.com/2017/06/27/Runtime方法交换机制/","excerpt":"","categories":[],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://charlsPrince.com/tags/iOS/"},{"name":"Runtime","slug":"Runtime","permalink":"http://charlsPrince.com/tags/Runtime/"}]},{"title":"创建属于自己的私有库","date":"2017-06-27T03:34:27.000Z","path":"2017/06/27/创建属于自己的私有库/","text":"相信每个Developer都会在使用Cocoapods这儿第三方库管理工具，虽然有时候pod install的时候会有种想死的感觉o(╯□╰)o，但依然无法阻挡某些程序员去使用它的热情，why？因为它能使你的项目工程看起来更加简洁，更加有条理性，而不至于使自己项目的Vendor文件夹看起来臃肿，而且能减少手动导入静态framework的麻烦，也可以将自己封装好的代码提交到Trunk供自己和别人使用，的确方便。 但有时候我们将代码封装起来后，想要重复利用，又不想push到Trunk(毕竟在又要验证又要被墙什么的，麻烦)，这时就需要使用到私有库了，作为小白和英语四级都没过的“程序猿”，在Cocoapods上的确踩了不少的坑，而且Cocoapods官网上面的流程看起来比较官方，只把一些主要的步骤标记出来，根本就没有一个完成的流程，而且全英文，看起来有点吃力(毕竟我是中国人O(∩_∩)O~) 那么我们就不扯远了，什么是私有库？ 私有库及公有库理解 在我看来，私有库就是自己封装的Code放到不开源的代码仓库，而GitHub就是一个管理开源Code的代码仓库，相信很多同学都是通过在GitHub上开源自己封装好的组件的，毕竟有好东西要学会分享✧(≖ ◡ ≖✿)嘿嘿 Cocoapods的原理及目录结构 Cocoapods一共分成两块，就是Cocoapods和Specs,Specs是一个目录容器，将所有的第三方的podspec存放在这里，而podspec就相当于是这个库的介绍文件，里面包含了库的名字、版本、下载地址等信息 注意项 ~/.cocoapods/repos/master 开源第三方库管理podspec的地方，这个文件夹是在使用Cocoapods的时候自动从Specs上clone到本地的基本目录结构：repos-&gt;master-&gt;Specs-&gt;[Name]-&gt;[Version]-&gt;[Name].podspec 这个就是共有的第三方的目录，我们要做私有库，可以模仿共有库的目录结构，建立一个自己的Spec私有仓库来维护，以后我们要维护的东西基本就两样： 121. 私有的Specs目录2. 我们要上传的库 步骤一、创建私有的Specs目录在远端(GitHub\\其他代码管理服务器，因为我使用的是GitHub，所以下文说到的远端都是指GitHub)建一个仓库，命名为MySpecs,将仓库clone到本地(可以是桌面或指定文件夹下)，将共有的Cocoapods-version.yml文件拷贝到里面，并创建一个命名为“Specs”的文件夹(在文件夹里面随意的文件，只要不是空文件夹就行了，因为如果是空文件夹的话在push到远端的时候会被忽略)，然后推送到远端，就这样，远端的Specs仓库已经创建完成了，这时本地和远端都会有了两个同步的库，如图： 二、将远端的私有Specs仓库clone到本地.cocoapods目录下在终端运行： $ pod repo add MySpecs https://github.com/CharlsPrince/MySpecs.git MySpecs 指的是仓库的名字，后面的路径就是仓库在远端的路径，这个是根据每个人远端仓库的路径而定的，将路径改成你的远端路径就行了 三、创建一个podspec文件cd到工程文件目录下 ，在终端执行命令： $ pod spec create CommonExtension https://github.com/CharlsPrince/CommonExtension.git CommonExtension 指的是这个podspec文件的名字，后面的路径就是这个工程在远端的路径，当然，如果要实现这一步，你需要先将你的工程push到远端，至于怎么push，这里就不详细介绍了，因为如果你使用不同的代码管理服务器方法也不尽相同，执行完了以后你会发现在当前的这个工程文件目录下回出现一个叫CommonExtension.podspec的文件 用sublime打开这个文件，没有sublime的也可以使用系统自带的文本编辑器打开，只不过用sublime打开可以将编辑语言改成Ruby，这样这些文本就会高亮显示了，编辑podspec里面的信息： 1234567891011121314151617181920s.name = &quot;xxxx&quot; #库的名字s.version = &quot;0.0.1&quot; #版本号，当私有库需要更新的时候只要修改这个值，自行维护s.summay = &quot;xxxxxx&quot; #库的简介，pod search 显示在上面的介绍s.description = &quot;xxxxxxxx&quot; #库的详细描述s.homepage = &quot;https://xxxx&quot; #主页地址，pod search 会显示，一般填写仓库的地址就行了s.license = &quot;MIT&quot; #开源协议，项目文件目录下需要有一个MIT开源协议文件s.author = &#123; &quot;name&quot; =&gt; &quot;xxxxxx@qq.com&quot; &#125; #作者名字、邮箱s.platform = :ios, &quot;7.0&quot; #库最低支持的系统版本s.source = &#123; :git =&gt; &quot;https://github.com/CharlsPrince/CommonExtension.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; #资源地址，pod install 的时候会根据这个地址去下载你的想要库，以及下载的版本，必须要跟s.version一致。s.source_files = &quot;xxxx&quot; #这个很重要，指定资源文件，前缀就是.podspec文件当前路径，只用写之后的路径，如Class/*是指Class文件夹下的所有文件，但不包括子文件夹里面的文件、Class/**/*是指包含所有Class文件夹下的文件，包括子文件、Class/**/*.&#123;h,m&#125;是指包含所有Class文件夹下的后缀为.h或.m的文件，当然也可以指定文件。s.requires_arc = true #是否支持arc&gt;&gt;&gt;&gt;&gt;以下是可选描述&lt;&lt;&lt;&lt;&lt;#s.resource = &quot;icon.png&quot; #资源文件，包括图片和xib文件# s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; #需要依赖的三方库#s.framework = &quot;SomeFramework&quot; #需要依赖的框架#s.public_header_files = &apos;&apos; #公开的头文件，如果不没公开，用户在用的时候可能引不到响应的头文件s.subspec &apos;subFolder&apos; do |ss| ss.source_files = &apos;Class/xxx/**/*.&#123;h,m&#125;&apos; ss.public_header_files = &quot;Class/xxx/**/*.&#123;h&#125;&quot;end #这个是子依赖库，因为如果我们只是用s.source_files来指定文件，那么用户在pod下来之后所有的文件都在同一个目录下，没有子文件夹，如果想要分下类，用s.subspec，每一个subspec可以分一个子文件夹，但是记得一定要将.h文件通过ss.public_header_files公开，不然有可能会找不到头文件。 当然还有一些其他的，详细介绍可以去Cocoapods看看或可以看看AFNetworking的podspec，他们写得很正规和简洁。 四、验证podspec合法性如果终端是在项目的当前目录下就直接执行一下命令，否则你需要cd到你要验证的.podspec的文件目录下： $ pod lib lint 或 $ pod spec lint 注意项 pod lib lint 所编译的源代码是来自于podspec所在目录而不是source所指定git地址 pod spec lint 会联网校验，通过source中的git地址获取源代码，同时还会校验git地址上是否有对应version字段的tag 执行完，如果有错就根据错误修改podspec文件，通过则继续 基本通过的话你就直接可以使用这个库了,可以创建一个工程试验一下，在这个新建个工程里面新建一个Podfile文件并输入 123pod &apos;[Name]&apos;, :podspec =&gt; &apos;/Users/xxxx/Desktop/xxx/xxx.podspec&apos;注：[Name]为pod spec中的s.name，必须一致，后面的路径为本地pod spec文件的路径。 然后cd到这个Podfile的目录下执行123pod install或pod install --no-repo-update 第二条命令是不更新官方Specs至本地，速度要比第一条快，没有必要每次都更新官方的Specs，这会使人崩溃。不出意外的话打开你这个工程，你会发现工程已经引入这个库了 五、向Specs远端提交.podspec文件cd到你的.podspec文件目录下验证通过后，给当前代码打上tag，建议tag和版本号一致，并push到远端(官网的tag是不能向下修改的),这时候打开你的远端，你会发现出现了你提交的tag $ git tag “0.0.1”$ git push origin –tags 将tag推送到远端以后，向自己的私有库提交podspec文件： $ pod repo push MySpecs [name].podspec 如果提交成功，去~/.cocoapods/repos/MySpecs文件夹下就能找到你创建的私有库了，当然，只是podspec文件哦，因为~/.cocoapods/repos/只是用来保存podspec文件的嘛 到这，你的私有库就已经创建完成了问题小结1、执行pod lib create （组件库） 出错 1234567提示错误：rubygems/core_ext/kernel_require.rb:120:in `require&apos;: cannot load such file -- colored2 (LoadError) 解决办法： 输入上面提示的colored2的两条gem命令即可解决问题 sudo gem install colored2 sudo gem update --system 2、添加组件库到私有spec repo仓库后 执行 pod search搜索不到。 1234567891011方法一： 先确认你本地仓库上面确实有你新创建的组件库，这时候可以先删除search缓存文件 rm ~/Library/Caches/CocoaPods/search_index.json ,删除后从新执行pod search *** 方法二： 1.切换到某个项目（含有podfile文件）下 2.执行pod update（提示不能更新） 3.尝试 pod repo update —verbose获取详细信息，我记得是提示我删除一个 index.lock文件，4.删除后从新 执行 pod repo update —verbose 会更新本地私有库和master仓库5.执行pod search *** 创建search索引，可以搜到 3、提交本地podspec到Specs仓库的时候出错，提示repo 文件夹下的spec repo is not clean 1234方法一: cd到spec repo 文件夹下，执行 git clean -f方法二：cd到spec repo 文件夹下，执行 git stash方法三: 删除spec repo 下的Specs仓库，我这里的是“MySpecs”,然后重新从git上将私有仓库clone下来：pod repo add MySpecs https://github.com/CharlsPrince/MySpecs.git 注意: 每次提交本地podspec到Specs仓库都要将Specs提交到git远程服务器，确保本地仓库与远程仓库同步 六、查询私有库并使用不出意外，这个时候，你去终端pod search 你的三方库名字，就能搜到（如果你的名字和官方Specs里面的某个三方库名字一样的话将会搜不到），使用的时候在Podfile中加入两个Specs源即：官方源： source ‘https://github.com/CocoaPods/Specs.git‘ 私有源： source ‘https://github.com/CharlsPrince/CommonExtension.git‘ #即你的私有源仓库地址 当然，你也可以指定地址 pod ‘xxxx’, :git =&gt;’https://github.com/CharlsPrince/CommonExtension.git‘ 或 pod ‘xxx’, :podspec =&gt; ‘xxxx.podspec’ 看到这个界面是不是有点小激动？之前弄的时候踩了不少坑，希望大家不要像我一样踩坑了！！！花了差不多一个下午时间才整理出来，希望能帮到同学们，谢谢，喜欢的点个👍。","raw":"---\ntitle: 创建属于自己的私有库\ndate: 2017-06-27 11:34:27\ntags: \n\t\t- Cocoapod\n\t\t- 私有库\n---\n\n相信每个Developer都会在使用Cocoapods这儿第三方库管理工具，虽然有时候pod install的时候会有种想死的感觉o(╯□╰)o，但依然无法阻挡某些程序员去使用它的热情，why？因为它能使你的项目工程看起来更加简洁，更加有条理性，而不至于使自己项目的Vendor文件夹看起来臃肿，而且能减少手动导入静态framework的麻烦，也可以将自己封装好的代码提交到Trunk供自己和别人使用，的确方便。\n\n但有时候我们将代码封装起来后，想要重复利用，又不想push到Trunk(毕竟在又要验证又要被墙什么的，麻烦)，这时就需要使用到私有库了，作为小白和英语四级都没过的“程序猿”，在Cocoapods上的确踩了不少的坑，而且Cocoapods官网上面的流程看起来比较官方，只把一些主要的步骤标记出来，根本就没有一个完成的流程，而且全英文，看起来有点吃力(毕竟我是中国人O(∩_∩)O~)\n\n那么我们就不扯远了，什么是私有库？\n\n## 私有库及公有库理解\n > 在我看来，私有库就是自己封装的Code放到不开源的代码仓库，而GitHub就是一个管理开源Code的代码仓库，相信很多同学都是通过在GitHub上开源自己封装好的组件的，毕竟有好东西要学会分享✧(≖ ◡ ≖✿)嘿嘿\n\n## Cocoapods的原理及目录结构\n\n > Cocoapods一共分成两块，就是[Cocoapods](https://github.com/CocoaPods/CocoaPods)和[Specs](https://github.com/CocoaPods/Specs),Specs是一个目录容器，将所有的第三方的podspec存放在这里，而podspec就相当于是这个库的介绍文件，里面包含了库的名字、版本、下载地址等信息\n \n### 注意项\n* ~/.cocoapods/repos/master\n\n> 开源第三方库管理podspec的地方，这个文件夹是在使用Cocoapods的时候自动从[Specs](https://github.com/CocoaPods/Specs)上clone到本地的\n> 基本目录结构：\n> repos->master->Specs->[Name]->[Version]->[Name].podspec\n\n这个就是共有的第三方的目录，我们要做私有库，可以模仿共有库的目录结构，建立一个自己的Spec私有仓库来维护，以后我们要维护的东西基本就两样：\n\n```\n1. 私有的Specs目录\n2. 我们要上传的库\n```\n\n## 步骤\n\n### 一、创建私有的Specs目录\n在远端(GitHub\\其他代码管理服务器，因为我使用的是GitHub，所以下文说到的远端都是指GitHub)建一个仓库，命名为MySpecs,将仓库clone到本地(可以是桌面或指定文件夹下)，将共有的Cocoapods-version.yml文件拷贝到里面，并创建一个命名为“Specs”的文件夹(在文件夹里面随意的文件，只要不是空文件夹就行了，因为如果是空文件夹的话在push到远端的时候会被忽略)，然后推送到远端，就这样，远端的Specs仓库已经创建完成了，这时本地和远端都会有了两个同步的库，如图：\n![本地仓库.png](http://upload-images.jianshu.io/upload_images/2925367-92ef309029175f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n![远程仓库.png](http://upload-images.jianshu.io/upload_images/2925367-87daf0ce282b7437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 二、将远端的私有Specs仓库clone到本地.cocoapods目录下\n\n在终端运行：\n>  $ pod repo add MySpecs https://github.com/CharlsPrince/MySpecs.git \n\nMySpecs 指的是仓库的名字，后面的路径就是仓库在远端的路径，这个是根据每个人远端仓库的路径而定的，将路径改成你的远端路径就行了\n\n### 三、创建一个podspec文件\ncd到工程文件目录下 ，在终端执行命令：\n> $ pod spec create CommonExtension https://github.com/CharlsPrince/CommonExtension.git\n\nCommonExtension 指的是这个podspec文件的名字，后面的路径就是这个工程在远端的路径，当然，如果要实现这一步，你需要先将你的工程push到远端，至于怎么push，这里就不详细介绍了，因为如果你使用不同的代码管理服务器方法也不尽相同，执行完了以后你会发现在当前的这个工程文件目录下回出现一个叫CommonExtension.podspec的文件\n\n![podspec文件.png](http://upload-images.jianshu.io/upload_images/2925367-f5b40d67b17ea557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n用sublime打开这个文件，没有sublime的也可以使用系统自带的文本编辑器打开，只不过用sublime打开可以将编辑语言改成Ruby，这样这些文本就会高亮显示了，编辑podspec里面的信息：\n\n```\ns.name = \"xxxx\" #库的名字\ns.version = \"0.0.1\" #版本号，当私有库需要更新的时候只要修改这个值，自行维护\ns.summay = \"xxxxxx\" #库的简介，pod search 显示在上面的介绍\ns.description = \"xxxxxxxx\" #库的详细描述\ns.homepage = \"https://xxxx\" #主页地址，pod search 会显示，一般填写仓库的地址就行了\ns.license = \"MIT\" #开源协议，项目文件目录下需要有一个MIT开源协议文件\ns.author = { \"name\" => \"xxxxxx@qq.com\" } #作者名字、邮箱\ns.platform = :ios, \"7.0\" #库最低支持的系统版本\ns.source = { :git => \"https://github.com/CharlsPrince/CommonExtension.git\", :tag => \"#{s.version}\" } #资源地址，pod install 的时候会根据这个地址去下载你的想要库，以及下载的版本，必须要跟s.version一致。\ns.source_files = \"xxxx\" #这个很重要，指定资源文件，前缀就是.podspec文件当前路径，只用写之后的路径，如Class/*是指Class文件夹下的所有文件，但不包括子文件夹里面的文件、Class/**/*是指包含所有Class文件夹下的文件，包括子文件、Class/**/*.{h,m}是指包含所有Class文件夹下的后缀为.h或.m的文件，当然也可以指定文件。\ns.requires_arc = true #是否支持arc\n>>>>>以下是可选描述<<<<<\n#s.resource  = \"icon.png\" #资源文件，包括图片和xib文件\n# s.dependency \"JSONKit\", \"~> 1.4\" #需要依赖的三方库\n#s.framework  = \"SomeFramework\" #需要依赖的框架\n#s.public_header_files = '' #公开的头文件，如果不没公开，用户在用的时候可能引不到响应的头文件\ns.subspec 'subFolder' do |ss|\n    ss.source_files = 'Class/xxx/**/*.{h,m}'\n    ss.public_header_files = \"Class/xxx/**/*.{h}\"\nend   #这个是子依赖库，因为如果我们只是用s.source_files来指定文件，那么用户在pod下来之后所有的文件都在同一个目录下，没有子文件夹，如果想要分下类，用s.subspec，每一个subspec可以分一个子文件夹，但是记得一定要将.h文件通过ss.public_header_files公开，不然有可能会找不到头文件。\n```\n当然还有一些其他的，详细介绍可以去Cocoapods看看或可以看看AFNetworking的podspec，他们写得很正规和简洁。\n\n### 四、验证podspec合法性\n如果终端是在项目的当前目录下就直接执行一下命令，否则你需要cd到你要验证的.podspec的文件目录下：\n> $ pod lib lint \n\n或\n\n> $ pod spec lint\n\n#### 注意项\n* pod lib lint 所编译的源代码是来自于podspec所在目录而不是source所指定git地址\n* pod spec lint 会联网校验，通过source中的git地址获取源代码，同时还会校验git地址上是否有对应version字段的tag\n* 执行完，如果有错就根据错误修改podspec文件，通过则继续\n* 基本通过的话你就直接可以使用这个库了,可以创建一个工程试验一下，在这个新建个工程里面新建一个Podfile文件并输入\n\n```\npod '[Name]', :podspec => '/Users/xxxx/Desktop/xxx/xxx.podspec'\n\n注：[Name]为pod spec中的s.name，必须一致，后面的路径为本地pod spec文件的路径。\n```\n* 然后cd到这个Podfile的目录下执行\n```\npod install\n或\npod install --no-repo-update\n```\n第二条命令是不更新官方Specs至本地，速度要比第一条快，没有必要每次都更新官方的Specs，这会使人崩溃。\n不出意外的话打开你这个工程，你会发现工程已经引入这个库了\n\n### 五、向Specs远端提交.podspec文件\ncd到你的.podspec文件目录下\n验证通过后，给当前代码打上tag，建议tag和版本号一致，并push到远端(官网的tag是不能向下修改的),这时候打开你的远端，你会发现出现了你提交的tag\n> $ git tag \"0.0.1\"\n>$ git push origin --tags\n\n![远端tag.png](http://upload-images.jianshu.io/upload_images/2925367-12e0e5035fcfa0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将tag推送到远端以后，向自己的私有库提交podspec文件：\n\n> $ pod repo push MySpecs [name].podspec\n\n如果提交成功，去`~/.cocoapods/repos/MySpecs`文件夹下就能找到你创建的私有库了，当然，只是podspec文件哦，因为`~/.cocoapods/repos/`只是用来保存podspec文件的嘛\n\n#### 到这，你的私有库就已经创建完成了\n\n#### 问题小结\n1、执行pod lib create （组件库） 出错\n\n```\n提示错误：rubygems/core_ext/kernel_require.rb:120:in `require': cannot load such file -- colored2  \n         (LoadError)\n\n 解决办法：\n     输入上面提示的colored2的两条gem命令即可解决问题\n   sudo gem install colored2\n   sudo gem update --system\n```\n2、添加组件库到私有spec repo仓库后 执行 pod search搜索不到。\n\n```\n方法一：\n        先确认你本地仓库上面确实有你新创建的组件库，这时候可以先删除search缓存文件\n    rm ~/Library/Caches/CocoaPods/search_index.json\n    ,删除后从新执行pod search ***\n\n    方法二：\n    1.切换到某个项目（含有podfile文件）下\n    2.执行pod update（提示不能更新）\n    3.尝试 pod repo update —verbose获取详细信息，我记得是提示我删除一个 index.lock文件，\n4.删除后从新 执行  pod repo update —verbose  会更新本地私有库和master仓库\n5.执行pod search ***   创建search索引，可以搜到\n```\n3、提交本地podspec到Specs仓库的时候出错，提示repo 文件夹下的spec repo is not clean\n\n```\n方法一: cd到spec repo 文件夹下，执行 git  clean -f\n方法二：cd到spec repo 文件夹下，执行  git  stash\n方法三: 删除spec repo 下的Specs仓库，我这里的是“MySpecs”,然后重新从git上将私有仓库clone下来：\npod repo add MySpecs https://github.com/CharlsPrince/MySpecs.git\n```\n![the repo \"xxx\" at \"xxx\" is no clean](https://ws3.sinaimg.cn/large/006tKfTcgy1fgziq673rjj30hx02cjri.jpg)\n\n\n## 注意:\n- 每次提交本地podspec到Specs仓库都要将Specs提交到git远程服务器，确保本地仓库与远程仓库同步\n\n\n\n\n\n### 六、查询私有库并使用\n不出意外，这个时候，你去终端pod search 你的三方库名字，就能搜到（如果你的名字和官方Specs里面的某个三方库名字一样的话将会搜不到），使用的时候在Podfile中加入两个Specs源即：\n官方源：\n\n> source 'https://github.com/CocoaPods/Specs.git'\n\n私有源：\n> source 'https://github.com/CharlsPrince/CommonExtension.git'  #即你的私有源仓库地址\n\n当然，你也可以指定地址\n> pod 'xxxx', :git =>'https://github.com/CharlsPrince/CommonExtension.git'\n\n或\n\n> pod 'xxx', :podspec => 'xxxx.podspec'\n\n![pod search.png](http://upload-images.jianshu.io/upload_images/2925367-a0acab8a91311285.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n看到这个界面是不是有点小激动？之前弄的时候踩了不少坑，希望大家不要像我一样踩坑了！！！花了差不多一个下午时间才整理出来，希望能帮到同学们，谢谢，喜欢的点个👍。\n\n\n","content":"<p>相信每个Developer都会在使用Cocoapods这儿第三方库管理工具，虽然有时候pod install的时候会有种想死的感觉o(╯□╰)o，但依然无法阻挡某些程序员去使用它的热情，why？因为它能使你的项目工程看起来更加简洁，更加有条理性，而不至于使自己项目的Vendor文件夹看起来臃肿，而且能减少手动导入静态framework的麻烦，也可以将自己封装好的代码提交到Trunk供自己和别人使用，的确方便。</p>\n<p>但有时候我们将代码封装起来后，想要重复利用，又不想push到Trunk(毕竟在又要验证又要被墙什么的，麻烦)，这时就需要使用到私有库了，作为小白和英语四级都没过的“程序猿”，在Cocoapods上的确踩了不少的坑，而且Cocoapods官网上面的流程看起来比较官方，只把一些主要的步骤标记出来，根本就没有一个完成的流程，而且全英文，看起来有点吃力(毕竟我是中国人O(∩_∩)O~)</p>\n<p>那么我们就不扯远了，什么是私有库？</p>\n<h2 id=\"私有库及公有库理解\"><a href=\"#私有库及公有库理解\" class=\"headerlink\" title=\"私有库及公有库理解\"></a>私有库及公有库理解</h2><blockquote>\n<p>在我看来，私有库就是自己封装的Code放到不开源的代码仓库，而GitHub就是一个管理开源Code的代码仓库，相信很多同学都是通过在GitHub上开源自己封装好的组件的，毕竟有好东西要学会分享✧(≖ ◡ ≖✿)嘿嘿</p>\n</blockquote>\n<h2 id=\"Cocoapods的原理及目录结构\"><a href=\"#Cocoapods的原理及目录结构\" class=\"headerlink\" title=\"Cocoapods的原理及目录结构\"></a>Cocoapods的原理及目录结构</h2><blockquote>\n<p>Cocoapods一共分成两块，就是<a href=\"https://github.com/CocoaPods/CocoaPods\" target=\"_blank\" rel=\"external\">Cocoapods</a>和<a href=\"https://github.com/CocoaPods/Specs\" target=\"_blank\" rel=\"external\">Specs</a>,Specs是一个目录容器，将所有的第三方的podspec存放在这里，而podspec就相当于是这个库的介绍文件，里面包含了库的名字、版本、下载地址等信息</p>\n</blockquote>\n<h3 id=\"注意项\"><a href=\"#注意项\" class=\"headerlink\" title=\"注意项\"></a>注意项</h3><ul>\n<li>~/.cocoapods/repos/master</li>\n</ul>\n<blockquote>\n<p>开源第三方库管理podspec的地方，这个文件夹是在使用Cocoapods的时候自动从<a href=\"https://github.com/CocoaPods/Specs\" target=\"_blank\" rel=\"external\">Specs</a>上clone到本地的<br>基本目录结构：<br>repos-&gt;master-&gt;Specs-&gt;[Name]-&gt;[Version]-&gt;[Name].podspec</p>\n</blockquote>\n<p>这个就是共有的第三方的目录，我们要做私有库，可以模仿共有库的目录结构，建立一个自己的Spec私有仓库来维护，以后我们要维护的东西基本就两样：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 私有的Specs目录</div><div class=\"line\">2. 我们要上传的库</div></pre></td></tr></table></figure>\n<h2 id=\"步骤\"><a href=\"#步骤\" class=\"headerlink\" title=\"步骤\"></a>步骤</h2><h3 id=\"一、创建私有的Specs目录\"><a href=\"#一、创建私有的Specs目录\" class=\"headerlink\" title=\"一、创建私有的Specs目录\"></a>一、创建私有的Specs目录</h3><p>在远端(GitHub\\其他代码管理服务器，因为我使用的是GitHub，所以下文说到的远端都是指GitHub)建一个仓库，命名为MySpecs,将仓库clone到本地(可以是桌面或指定文件夹下)，将共有的Cocoapods-version.yml文件拷贝到里面，并创建一个命名为“Specs”的文件夹(在文件夹里面随意的文件，只要不是空文件夹就行了，因为如果是空文件夹的话在push到远端的时候会被忽略)，然后推送到远端，就这样，远端的Specs仓库已经创建完成了，这时本地和远端都会有了两个同步的库，如图：<br><img src=\"http://upload-images.jianshu.io/upload_images/2925367-92ef309029175f55.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"本地仓库.png\"></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-87daf0ce282b7437.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"远程仓库.png\"></p>\n<h3 id=\"二、将远端的私有Specs仓库clone到本地-cocoapods目录下\"><a href=\"#二、将远端的私有Specs仓库clone到本地-cocoapods目录下\" class=\"headerlink\" title=\"二、将远端的私有Specs仓库clone到本地.cocoapods目录下\"></a>二、将远端的私有Specs仓库clone到本地.cocoapods目录下</h3><p>在终端运行：</p>\n<blockquote>\n<p> $ pod repo add MySpecs <a href=\"https://github.com/CharlsPrince/MySpecs.git\" target=\"_blank\" rel=\"external\">https://github.com/CharlsPrince/MySpecs.git</a> </p>\n</blockquote>\n<p>MySpecs 指的是仓库的名字，后面的路径就是仓库在远端的路径，这个是根据每个人远端仓库的路径而定的，将路径改成你的远端路径就行了</p>\n<h3 id=\"三、创建一个podspec文件\"><a href=\"#三、创建一个podspec文件\" class=\"headerlink\" title=\"三、创建一个podspec文件\"></a>三、创建一个podspec文件</h3><p>cd到工程文件目录下 ，在终端执行命令：</p>\n<blockquote>\n<p>$ pod spec create CommonExtension <a href=\"https://github.com/CharlsPrince/CommonExtension.git\" target=\"_blank\" rel=\"external\">https://github.com/CharlsPrince/CommonExtension.git</a></p>\n</blockquote>\n<p>CommonExtension 指的是这个podspec文件的名字，后面的路径就是这个工程在远端的路径，当然，如果要实现这一步，你需要先将你的工程push到远端，至于怎么push，这里就不详细介绍了，因为如果你使用不同的代码管理服务器方法也不尽相同，执行完了以后你会发现在当前的这个工程文件目录下回出现一个叫CommonExtension.podspec的文件</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-f5b40d67b17ea557.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"podspec文件.png\"></p>\n<p>用sublime打开这个文件，没有sublime的也可以使用系统自带的文本编辑器打开，只不过用sublime打开可以将编辑语言改成Ruby，这样这些文本就会高亮显示了，编辑podspec里面的信息：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">s.name = &quot;xxxx&quot; #库的名字</div><div class=\"line\">s.version = &quot;0.0.1&quot; #版本号，当私有库需要更新的时候只要修改这个值，自行维护</div><div class=\"line\">s.summay = &quot;xxxxxx&quot; #库的简介，pod search 显示在上面的介绍</div><div class=\"line\">s.description = &quot;xxxxxxxx&quot; #库的详细描述</div><div class=\"line\">s.homepage = &quot;https://xxxx&quot; #主页地址，pod search 会显示，一般填写仓库的地址就行了</div><div class=\"line\">s.license = &quot;MIT&quot; #开源协议，项目文件目录下需要有一个MIT开源协议文件</div><div class=\"line\">s.author = &#123; &quot;name&quot; =&gt; &quot;xxxxxx@qq.com&quot; &#125; #作者名字、邮箱</div><div class=\"line\">s.platform = :ios, &quot;7.0&quot; #库最低支持的系统版本</div><div class=\"line\">s.source = &#123; :git =&gt; &quot;https://github.com/CharlsPrince/CommonExtension.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125; #资源地址，pod install 的时候会根据这个地址去下载你的想要库，以及下载的版本，必须要跟s.version一致。</div><div class=\"line\">s.source_files = &quot;xxxx&quot; #这个很重要，指定资源文件，前缀就是.podspec文件当前路径，只用写之后的路径，如Class/*是指Class文件夹下的所有文件，但不包括子文件夹里面的文件、Class/**/*是指包含所有Class文件夹下的文件，包括子文件、Class/**/*.&#123;h,m&#125;是指包含所有Class文件夹下的后缀为.h或.m的文件，当然也可以指定文件。</div><div class=\"line\">s.requires_arc = true #是否支持arc</div><div class=\"line\">&gt;&gt;&gt;&gt;&gt;以下是可选描述&lt;&lt;&lt;&lt;&lt;</div><div class=\"line\">#s.resource  = &quot;icon.png&quot; #资源文件，包括图片和xib文件</div><div class=\"line\"># s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; #需要依赖的三方库</div><div class=\"line\">#s.framework  = &quot;SomeFramework&quot; #需要依赖的框架</div><div class=\"line\">#s.public_header_files = &apos;&apos; #公开的头文件，如果不没公开，用户在用的时候可能引不到响应的头文件</div><div class=\"line\">s.subspec &apos;subFolder&apos; do |ss|</div><div class=\"line\">    ss.source_files = &apos;Class/xxx/**/*.&#123;h,m&#125;&apos;</div><div class=\"line\">    ss.public_header_files = &quot;Class/xxx/**/*.&#123;h&#125;&quot;</div><div class=\"line\">end   #这个是子依赖库，因为如果我们只是用s.source_files来指定文件，那么用户在pod下来之后所有的文件都在同一个目录下，没有子文件夹，如果想要分下类，用s.subspec，每一个subspec可以分一个子文件夹，但是记得一定要将.h文件通过ss.public_header_files公开，不然有可能会找不到头文件。</div></pre></td></tr></table></figure>\n<p>当然还有一些其他的，详细介绍可以去Cocoapods看看或可以看看AFNetworking的podspec，他们写得很正规和简洁。</p>\n<h3 id=\"四、验证podspec合法性\"><a href=\"#四、验证podspec合法性\" class=\"headerlink\" title=\"四、验证podspec合法性\"></a>四、验证podspec合法性</h3><p>如果终端是在项目的当前目录下就直接执行一下命令，否则你需要cd到你要验证的.podspec的文件目录下：</p>\n<blockquote>\n<p>$ pod lib lint </p>\n</blockquote>\n<p>或</p>\n<blockquote>\n<p>$ pod spec lint</p>\n</blockquote>\n<h4 id=\"注意项-1\"><a href=\"#注意项-1\" class=\"headerlink\" title=\"注意项\"></a>注意项</h4><ul>\n<li>pod lib lint 所编译的源代码是来自于podspec所在目录而不是source所指定git地址</li>\n<li>pod spec lint 会联网校验，通过source中的git地址获取源代码，同时还会校验git地址上是否有对应version字段的tag</li>\n<li>执行完，如果有错就根据错误修改podspec文件，通过则继续</li>\n<li>基本通过的话你就直接可以使用这个库了,可以创建一个工程试验一下，在这个新建个工程里面新建一个Podfile文件并输入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod &apos;[Name]&apos;, :podspec =&gt; &apos;/Users/xxxx/Desktop/xxx/xxx.podspec&apos;</div><div class=\"line\"></div><div class=\"line\">注：[Name]为pod spec中的s.name，必须一致，后面的路径为本地pod spec文件的路径。</div></pre></td></tr></table></figure>\n<ul>\n<li>然后cd到这个Podfile的目录下执行<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">pod install</div><div class=\"line\">或</div><div class=\"line\">pod install --no-repo-update</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>第二条命令是不更新官方Specs至本地，速度要比第一条快，没有必要每次都更新官方的Specs，这会使人崩溃。<br>不出意外的话打开你这个工程，你会发现工程已经引入这个库了</p>\n<h3 id=\"五、向Specs远端提交-podspec文件\"><a href=\"#五、向Specs远端提交-podspec文件\" class=\"headerlink\" title=\"五、向Specs远端提交.podspec文件\"></a>五、向Specs远端提交.podspec文件</h3><p>cd到你的.podspec文件目录下<br>验证通过后，给当前代码打上tag，建议tag和版本号一致，并push到远端(官网的tag是不能向下修改的),这时候打开你的远端，你会发现出现了你提交的tag</p>\n<blockquote>\n<p>$ git tag “0.0.1”<br>$ git push origin –tags</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-12e0e5035fcfa0d4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"远端tag.png\"></p>\n<p>将tag推送到远端以后，向自己的私有库提交podspec文件：</p>\n<blockquote>\n<p>$ pod repo push MySpecs [name].podspec</p>\n</blockquote>\n<p>如果提交成功，去<code>~/.cocoapods/repos/MySpecs</code>文件夹下就能找到你创建的私有库了，当然，只是podspec文件哦，因为<code>~/.cocoapods/repos/</code>只是用来保存podspec文件的嘛</p>\n<h4 id=\"到这，你的私有库就已经创建完成了\"><a href=\"#到这，你的私有库就已经创建完成了\" class=\"headerlink\" title=\"到这，你的私有库就已经创建完成了\"></a>到这，你的私有库就已经创建完成了</h4><h4 id=\"问题小结\"><a href=\"#问题小结\" class=\"headerlink\" title=\"问题小结\"></a>问题小结</h4><p>1、执行pod lib create （组件库） 出错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">提示错误：rubygems/core_ext/kernel_require.rb:120:in `require&apos;: cannot load such file -- colored2  </div><div class=\"line\">         (LoadError)</div><div class=\"line\"></div><div class=\"line\"> 解决办法：</div><div class=\"line\">     输入上面提示的colored2的两条gem命令即可解决问题</div><div class=\"line\">   sudo gem install colored2</div><div class=\"line\">   sudo gem update --system</div></pre></td></tr></table></figure>\n<p>2、添加组件库到私有spec repo仓库后 执行 pod search搜索不到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">方法一：</div><div class=\"line\">        先确认你本地仓库上面确实有你新创建的组件库，这时候可以先删除search缓存文件</div><div class=\"line\">    rm ~/Library/Caches/CocoaPods/search_index.json</div><div class=\"line\">    ,删除后从新执行pod search ***</div><div class=\"line\"></div><div class=\"line\">    方法二：</div><div class=\"line\">    1.切换到某个项目（含有podfile文件）下</div><div class=\"line\">    2.执行pod update（提示不能更新）</div><div class=\"line\">    3.尝试 pod repo update —verbose获取详细信息，我记得是提示我删除一个 index.lock文件，</div><div class=\"line\">4.删除后从新 执行  pod repo update —verbose  会更新本地私有库和master仓库</div><div class=\"line\">5.执行pod search ***   创建search索引，可以搜到</div></pre></td></tr></table></figure>\n<p>3、提交本地podspec到Specs仓库的时候出错，提示repo 文件夹下的spec repo is not clean</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">方法一: cd到spec repo 文件夹下，执行 git  clean -f</div><div class=\"line\">方法二：cd到spec repo 文件夹下，执行  git  stash</div><div class=\"line\">方法三: 删除spec repo 下的Specs仓库，我这里的是“MySpecs”,然后重新从git上将私有仓库clone下来：</div><div class=\"line\">pod repo add MySpecs https://github.com/CharlsPrince/MySpecs.git</div></pre></td></tr></table></figure>\n<p><img src=\"https://ws3.sinaimg.cn/large/006tKfTcgy1fgziq673rjj30hx02cjri.jpg\" alt=\"the repo &quot;xxx&quot; at &quot;xxx&quot; is no clean\"></p>\n<h2 id=\"注意\"><a href=\"#注意\" class=\"headerlink\" title=\"注意:\"></a>注意:</h2><ul>\n<li>每次提交本地podspec到Specs仓库都要将Specs提交到git远程服务器，确保本地仓库与远程仓库同步</li>\n</ul>\n<h3 id=\"六、查询私有库并使用\"><a href=\"#六、查询私有库并使用\" class=\"headerlink\" title=\"六、查询私有库并使用\"></a>六、查询私有库并使用</h3><p>不出意外，这个时候，你去终端pod search 你的三方库名字，就能搜到（如果你的名字和官方Specs里面的某个三方库名字一样的话将会搜不到），使用的时候在Podfile中加入两个Specs源即：<br>官方源：</p>\n<blockquote>\n<p>source ‘<a href=\"https://github.com/CocoaPods/Specs.git\" target=\"_blank\" rel=\"external\">https://github.com/CocoaPods/Specs.git</a>‘</p>\n</blockquote>\n<p>私有源：</p>\n<blockquote>\n<p>source ‘<a href=\"https://github.com/CharlsPrince/CommonExtension.git\" target=\"_blank\" rel=\"external\">https://github.com/CharlsPrince/CommonExtension.git</a>‘  #即你的私有源仓库地址</p>\n</blockquote>\n<p>当然，你也可以指定地址</p>\n<blockquote>\n<p>pod ‘xxxx’, :git =&gt;’<a href=\"https://github.com/CharlsPrince/CommonExtension.git\" target=\"_blank\" rel=\"external\">https://github.com/CharlsPrince/CommonExtension.git</a>‘</p>\n</blockquote>\n<p>或</p>\n<blockquote>\n<p>pod ‘xxx’, :podspec =&gt; ‘xxxx.podspec’</p>\n</blockquote>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2925367-a0acab8a91311285.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"pod search.png\"></p>\n<p>看到这个界面是不是有点小激动？之前弄的时候踩了不少坑，希望大家不要像我一样踩坑了！！！花了差不多一个下午时间才整理出来，希望能帮到同学们，谢谢，喜欢的点个👍。</p>\n","slug":"创建属于自己的私有库","updated":"2017-06-27T05:06:13.000Z","comments":true,"link":"","permalink":"http://charlsPrince.com/2017/06/27/创建属于自己的私有库/","excerpt":"","categories":[],"tags":[{"name":"Cocoapod","slug":"Cocoapod","permalink":"http://charlsPrince.com/tags/Cocoapod/"},{"name":"私有库","slug":"私有库","permalink":"http://charlsPrince.com/tags/私有库/"}]},{"title":"Cordova概要","date":"2017-06-23T12:30:50.000Z","path":"2017/06/23/Cordova概要/","text":"安装Cordova CLI 下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm 。 (可选)下载和安装git client, 如果你没有。安装成功后，你可以在命令行中使用git。 这个命令行使用下载git仓库中的资源。 安装cordova 模块使用Nodejs的npm工具。cordova模块会被npm工具自动下载。 在OS X和Linux上:1$ sudo npm install -g cordova 在OS X和Linux上, npm命令加上前缀sudo因为cordova可能需要安装在其他的受限制目录比如 /usr/local/share。如果你使用可选工具nvm/nave或者具有安装目录的写权限，那么你可以省略sudo前缀。这里有更多提示 可用在使用 npm 没有 sudo前缀时，如果你想那么做。 在Windows上:1C:\\&gt;npm install -g cordova -g 标志是告诉 npm 我们全局安装 cordova。否则我们将会安装在当前工作目录的 node_modules 子目录。 安装完成后，你应该能够在命令行中运行cordova命令，在没有任何参数的时候会打印一些帮助信息。 创建Appcd 到你想要保存的项目路径，使用一下命令创建cordova项目:1$ cordova create hello com.example.hello HelloWorld 添加平台 cd 到项目根目录 1$ cd hello 给你的App添加目标平台。我们将会添加’ios’和’android’平台，并确保他们保存在了config.xml中: 12$ cordova platform add ios --save$ cordova platform add android --save 检查你当前平台设置状况: 1$ cordova platform ls 构建App默认情况下, cordova create生产基于web应用程序的骨架，项目开始页面位于www/index.html 文件。任何初始化任务应该在www/js/index.js文件中的deviceready事件的事件处理函数中。 运行下面命令为所有添加的平台构建: 1$ cordova build 你可以在每次构建中选择限制平台范围 - 这个例子中是’ios’: 1$ cordova build ios 启动服务1$ cordova serve ios 模拟器运行1234$ cordova emulate ios## 指定模拟器版本 ##$ cordova emulate ios --target iPhone-6s$ cordova emulate ios --target iPhone-6s-Plus 真机调试先装ios-deploy:1npm install -g ios-deploy 再配置好证书之类的，然后运行：1cordova run ios --device 插件插件常用命令:查看所有已经安装的插件1cordova plugin ls 安装插件(如)1cordova plugin add cordova-plugin-camera 删除插件1cordova plugin rm cordova-plugin-camera 更新插件1cordova plugin update 常用插件1，Console（调试控制台）让程序可以在控制台中打印输出日志。 1cordova plugin add cordova-plugin-console 2，Connection（网络连接）用来判断网络连接类型（2G、3G、4G、Wifi、无连接等） 1cordova plugin add cordova-plugin-network-information 3，Device（设备）获取一些设备信息。 1cordova plugin add cordova-plugin-device 4，HardwareNofifications（硬件消息提醒）让设备蜂鸣或振动。 1cordova plugin add cordova-plugin-vibration 5，Visual Notification（可视化消息提醒）不同于js的alert()、confirm()和prompt()方法是同步的。Cordova的alert()、confirm()和prompt()方法是异步的，并且对显示内容有更大的控制权限。 1cordova plugin add cordova-plugin-dialogs 6，Battery（电池）可以获取电池状态信息。 1cordova plugin add cordova-plugin-battery-status 7，Accelerometer(加速计)让应用在三维空间(使用笛卡尔三维坐标系统)中决定设备方向。 1cordova plugin add cordova-plugin-device-motion 8，Compass(指南针)可以让开发者读取移动设备的朝向。 1cordova plugin add cordova-plugin-device-orientation 9，Geolocation(地理定位)让应用判断设备的物理位置。 1cordova plugin add cordova-plugin-geolocation 10，Camera(相机)用相机获取图像。 1cordova plugin add cordova-plugin-camera 11，Media Capture （媒体捕获）与Camera API相比，不仅能获取图像，还可以录视频或者录音。 1cordova plugin add cordova-plugin-media-capture 12，Globalization(全球化)允许应用查询操作系统的当前设置，判断用户使用的语言。 1cordova plugin add cordova-plugin-globalization 13，Contacts（联系人）读取联系人列表并在应用中使用联系人数据，或使用应用数据向联系人列表中写新的联系人。 1cordova plugin add cordova-plugin-contacts 14，Media（播放/记录媒体文件）让应用能记录或播放媒体文件。用它可以在手机后台播放音频文件或玩桌面视频游戏。 1cordova plugin add cordova-plugin-media 15，InAppBrowser（内置浏览器）允许在在单独的窗口中加载网页。例如要向应用用户展示其他网页。当然可以很容易地在应用中加载网页内容并管理，但有时候需要不同的用户体验，InAppBrowser加载网页内容，应用用户可以更方便的直接返回到主应用。 1cordova plugin add cordova-plugin-inappbrowser 16，Splashscreen（闪屏）用来在Cordova应用启动时显示自定义的闪屏。 1cordova plugin add cordova-plugin-splashscreen 17，exitApp（退出应用）让 Android 或者 Windows Phone 8 上的APP关闭退出（iOS系统不支持）。 1cordova plugin add cordova-plugin-exitapp 18，barcodeScanner（条形码/二维码扫描）不仅可以通过摄像头识别二维码/条形码，还能生成二维码。 1cordova plugin add cordova-plugin-barcodescanner 19，file（文件访问操作类）提供对设备上的文件进行读取和写入的功能支持。 1cordova plugin add cordova-plugin-file 20，fileTransfer（文件传输）实现文件上传、下载及共享等功能。 1cordova plugin add cordova-plugin-file-transfer","raw":"---\ntitle: Cordova概要\ndate: 2017-06-23 20:30:50\ntags:\n\t\t- 混合开发\n\t\t- Cordova\n---\n\n## 安装Cordova CLI\n1. 下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm 。\n2. (可选)下载和安装git client, 如果你没有。安装成功后，你可以在命令行中使用git。 这个命令行使用下载git仓库中的资源。\n3. 安装cordova 模块使用Nodejs的npm工具。cordova模块会被npm工具自动下载。\n\n- 在OS X和Linux上:\n```\n$ sudo npm install -g cordova\n```\n在OS X和Linux上, npm命令加上前缀sudo因为cordova可能需要安装在其他的受限制目录比如 /usr/local/share。如果你使用可选工具nvm/nave或者具有安装目录的写权限，那么你可以省略sudo前缀。这里有更多提示 可用在使用 npm 没有 sudo前缀时，如果你想那么做。\n\n- 在Windows上:\n```\nC:\\>npm install -g cordova\n```\n`-g` 标志是告诉 `npm` 我们全局安装 `cordova`。否则我们将会安装在当前工作目录的 `node_modules` 子目录。\n\n安装完成后，你应该能够在命令行中运行`cordova`命令，在没有任何参数的时候会打印一些帮助信息。\n\n## 创建App\ncd 到你想要保存的项目路径，使用一下命令创建cordova项目:\n```\n$ cordova create hello com.example.hello HelloWorld\n```\n\n## 添加平台\n- cd 到项目根目录\n\n```\n$ cd hello\n```\n- 给你的App添加目标平台。我们将会添加'ios'和'android'平台，并确保他们保存在了config.xml中:\n\n```\n$ cordova platform add ios --save\n$ cordova platform add android --save\n```\n- 检查你当前平台设置状况:\n\n```\n$ cordova platform ls\n```\n\n## 构建App\n\n默认情况下, cordova create生产基于web应用程序的骨架，项目开始页面位于www/index.html 文件。任何初始化任务应该在www/js/index.js文件中的deviceready事件的事件处理函数中。\n\n运行下面命令为所有添加的平台构建:\n\n\n```\n$ cordova build \n```\n\n你可以在每次构建中选择限制平台范围 - 这个例子中是'ios':\n\n\n```\n$ cordova build ios\n```\n\n## 启动服务\n\n```\n$ cordova serve ios\n```\n\n\n## 模拟器运行\n\n```\n$ cordova emulate ios\n## 指定模拟器版本 ##\n$ cordova emulate ios --target iPhone-6s\n$ cordova emulate ios --target iPhone-6s-Plus\n```\n\n\n## 真机调试\n先装ios-deploy:\n```\nnpm install -g ios-deploy\n```\n再配置好证书之类的，然后运行：\n```\ncordova run ios --device\n```\n\n## 插件\n\n### 插件常用命令:\n\n#### 查看所有已经安装的插件\n\n```\ncordova plugin ls\n```\n\n#### 安装插件(如)\n\n```\ncordova plugin add cordova-plugin-camera\n```\n\n#### 删除插件\n\n```\ncordova plugin rm cordova-plugin-camera\n```\n\n#### 更新插件\n\n```\ncordova plugin update\n```\n\n### 常用插件\n#### 1，Console（调试控制台）\n\n让程序可以在控制台中打印输出日志。\n\n```\ncordova plugin add cordova-plugin-console\n```\n\n#### 2，Connection（网络连接）\n\n用来判断网络连接类型（2G、3G、4G、Wifi、无连接等）\n\n\n```\ncordova plugin add cordova-plugin-network-information\n```\n\n\n#### 3，Device（设备）\n\n获取一些设备信息。\n\n\n```\ncordova plugin add cordova-plugin-device\n```\n\n\n#### 4，Hardware\n\nNofifications（硬件消息提醒）\n让设备蜂鸣或振动。\n\n\n```\ncordova plugin add cordova-plugin-vibration\n```\n\n\n#### 5，Visual Notification（可视化消息提醒）\n\n不同于js的alert()、confirm()和prompt()方法是同步的。Cordova的alert()、confirm()和prompt()方法是异步的，并且对显示内容有更大的控制权限。\n\n\n```\ncordova plugin add cordova-plugin-dialogs\n```\n\n\n#### 6，Battery（电池）\n\n可以获取电池状态信息。\n\n\n```\ncordova plugin add cordova-plugin-battery-status\n```\n\n\n#### 7，Accelerometer(加速计)\n\n让应用在三维空间(使用笛卡尔三维坐标系统)中决定设备方向。\n\n```\ncordova plugin add cordova-plugin-device-motion\n```\n\n\n#### 8，Compass(指南针)\n\n可以让开发者读取移动设备的朝向。\n\n\n```\ncordova plugin add cordova-plugin-device-orientation\n```\n\n\n#### 9，Geolocation(地理定位)\n\n让应用判断设备的物理位置。\n\n\n```\ncordova plugin add cordova-plugin-geolocation\n```\n\n\n#### 10，Camera(相机)\n\n用相机获取图像。\n\n\n```\ncordova plugin add cordova-plugin-camera\n```\n\n\n#### 11，Media Capture （媒体捕获）\n\n与Camera API相比，不仅能获取图像，还可以录视频或者录音。\n\n\n```\ncordova plugin add cordova-plugin-media-capture\n```\n\n\n#### 12，Globalization(全球化)\n\n允许应用查询操作系统的当前设置，判断用户使用的语言。\n\n\n```\ncordova plugin add cordova-plugin-globalization\n```\n\n\n#### 13，Contacts（联系人）\n\n读取联系人列表并在应用中使用联系人数据，或使用应用数据向联系人列表中写新的联系人。\n\n\n```\ncordova plugin add cordova-plugin-contacts\n```\n\n\n#### 14，Media（播放/记录媒体文件）\n\n让应用能记录或播放媒体文件。用它可以在手机后台播放音频文件或玩桌面视频游戏。\n\n\n```\ncordova plugin add cordova-plugin-media\n```\n\n\n#### 15，InAppBrowser（内置浏览器）\n\n允许在在单独的窗口中加载网页。例如要向应用用户展示其他网页。当然可以很容易地在应用中加载网页内容并管理，但有时候需要不同的用户体验，InAppBrowser加载网页内容，应用用户可以更方便的直接返回到主应用。\n\n\n```\ncordova plugin add cordova-plugin-inappbrowser\n```\n\n\n#### 16，Splashscreen（闪屏）\n\n用来在Cordova应用启动时显示自定义的闪屏。\n\n\n```\ncordova plugin add cordova-plugin-splashscreen\n```\n\n\n#### 17，exitApp（退出应用）\n\n让 Android 或者 Windows Phone 8 上的APP关闭退出（iOS系统不支持）。\n\n\n```\ncordova plugin add cordova-plugin-exitapp\n```\n\n\n#### 18，barcodeScanner（条形码/二维码扫描）\n\n不仅可以通过摄像头识别二维码/条形码，还能生成二维码。\n\n\n```\ncordova plugin add cordova-plugin-barcodescanner\n```\n\n\n#### 19，file（文件访问操作类）\n\n提供对设备上的文件进行读取和写入的功能支持。\n\n\n```\ncordova plugin add cordova-plugin-file\n```\n\n\n#### 20，fileTransfer（文件传输）\n\n实现文件上传、下载及共享等功能。\n\n\n```\ncordova plugin add cordova-plugin-file-transfer\n```\n\n","content":"<h2 id=\"安装Cordova-CLI\"><a href=\"#安装Cordova-CLI\" class=\"headerlink\" title=\"安装Cordova CLI\"></a>安装Cordova CLI</h2><ol>\n<li>下载和安装Node.js。安装完成后你可以在命令行中使用node 和 npm 。</li>\n<li>(可选)下载和安装git client, 如果你没有。安装成功后，你可以在命令行中使用git。 这个命令行使用下载git仓库中的资源。</li>\n<li>安装cordova 模块使用Nodejs的npm工具。cordova模块会被npm工具自动下载。</li>\n</ol>\n<ul>\n<li>在OS X和Linux上:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ sudo npm install -g cordova</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>在OS X和Linux上, npm命令加上前缀sudo因为cordova可能需要安装在其他的受限制目录比如 /usr/local/share。如果你使用可选工具nvm/nave或者具有安装目录的写权限，那么你可以省略sudo前缀。这里有更多提示 可用在使用 npm 没有 sudo前缀时，如果你想那么做。</p>\n<ul>\n<li>在Windows上:<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">C:\\&gt;npm install -g cordova</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><code>-g</code> 标志是告诉 <code>npm</code> 我们全局安装 <code>cordova</code>。否则我们将会安装在当前工作目录的 <code>node_modules</code> 子目录。</p>\n<p>安装完成后，你应该能够在命令行中运行<code>cordova</code>命令，在没有任何参数的时候会打印一些帮助信息。</p>\n<h2 id=\"创建App\"><a href=\"#创建App\" class=\"headerlink\" title=\"创建App\"></a>创建App</h2><p>cd 到你想要保存的项目路径，使用一下命令创建cordova项目:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova create hello com.example.hello HelloWorld</div></pre></td></tr></table></figure></p>\n<h2 id=\"添加平台\"><a href=\"#添加平台\" class=\"headerlink\" title=\"添加平台\"></a>添加平台</h2><ul>\n<li>cd 到项目根目录</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cd hello</div></pre></td></tr></table></figure>\n<ul>\n<li>给你的App添加目标平台。我们将会添加’ios’和’android’平台，并确保他们保存在了config.xml中:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova platform add ios --save</div><div class=\"line\">$ cordova platform add android --save</div></pre></td></tr></table></figure>\n<ul>\n<li>检查你当前平台设置状况:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova platform ls</div></pre></td></tr></table></figure>\n<h2 id=\"构建App\"><a href=\"#构建App\" class=\"headerlink\" title=\"构建App\"></a>构建App</h2><p>默认情况下, cordova create生产基于web应用程序的骨架，项目开始页面位于www/index.html 文件。任何初始化任务应该在www/js/index.js文件中的deviceready事件的事件处理函数中。</p>\n<p>运行下面命令为所有添加的平台构建:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova build</div></pre></td></tr></table></figure>\n<p>你可以在每次构建中选择限制平台范围 - 这个例子中是’ios’:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova build ios</div></pre></td></tr></table></figure>\n<h2 id=\"启动服务\"><a href=\"#启动服务\" class=\"headerlink\" title=\"启动服务\"></a>启动服务</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova serve ios</div></pre></td></tr></table></figure>\n<h2 id=\"模拟器运行\"><a href=\"#模拟器运行\" class=\"headerlink\" title=\"模拟器运行\"></a>模拟器运行</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ cordova emulate ios</div><div class=\"line\">## 指定模拟器版本 ##</div><div class=\"line\">$ cordova emulate ios --target iPhone-6s</div><div class=\"line\">$ cordova emulate ios --target iPhone-6s-Plus</div></pre></td></tr></table></figure>\n<h2 id=\"真机调试\"><a href=\"#真机调试\" class=\"headerlink\" title=\"真机调试\"></a>真机调试</h2><p>先装ios-deploy:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g ios-deploy</div></pre></td></tr></table></figure></p>\n<p>再配置好证书之类的，然后运行：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova run ios --device</div></pre></td></tr></table></figure></p>\n<h2 id=\"插件\"><a href=\"#插件\" class=\"headerlink\" title=\"插件\"></a>插件</h2><h3 id=\"插件常用命令\"><a href=\"#插件常用命令\" class=\"headerlink\" title=\"插件常用命令:\"></a>插件常用命令:</h3><h4 id=\"查看所有已经安装的插件\"><a href=\"#查看所有已经安装的插件\" class=\"headerlink\" title=\"查看所有已经安装的插件\"></a>查看所有已经安装的插件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin ls</div></pre></td></tr></table></figure>\n<h4 id=\"安装插件-如\"><a href=\"#安装插件-如\" class=\"headerlink\" title=\"安装插件(如)\"></a>安装插件(如)</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-camera</div></pre></td></tr></table></figure>\n<h4 id=\"删除插件\"><a href=\"#删除插件\" class=\"headerlink\" title=\"删除插件\"></a>删除插件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin rm cordova-plugin-camera</div></pre></td></tr></table></figure>\n<h4 id=\"更新插件\"><a href=\"#更新插件\" class=\"headerlink\" title=\"更新插件\"></a>更新插件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin update</div></pre></td></tr></table></figure>\n<h3 id=\"常用插件\"><a href=\"#常用插件\" class=\"headerlink\" title=\"常用插件\"></a>常用插件</h3><h4 id=\"1，Console（调试控制台）\"><a href=\"#1，Console（调试控制台）\" class=\"headerlink\" title=\"1，Console（调试控制台）\"></a>1，Console（调试控制台）</h4><p>让程序可以在控制台中打印输出日志。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-console</div></pre></td></tr></table></figure>\n<h4 id=\"2，Connection（网络连接）\"><a href=\"#2，Connection（网络连接）\" class=\"headerlink\" title=\"2，Connection（网络连接）\"></a>2，Connection（网络连接）</h4><p>用来判断网络连接类型（2G、3G、4G、Wifi、无连接等）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-network-information</div></pre></td></tr></table></figure>\n<h4 id=\"3，Device（设备）\"><a href=\"#3，Device（设备）\" class=\"headerlink\" title=\"3，Device（设备）\"></a>3，Device（设备）</h4><p>获取一些设备信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-device</div></pre></td></tr></table></figure>\n<h4 id=\"4，Hardware\"><a href=\"#4，Hardware\" class=\"headerlink\" title=\"4，Hardware\"></a>4，Hardware</h4><p>Nofifications（硬件消息提醒）<br>让设备蜂鸣或振动。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-vibration</div></pre></td></tr></table></figure>\n<h4 id=\"5，Visual-Notification（可视化消息提醒）\"><a href=\"#5，Visual-Notification（可视化消息提醒）\" class=\"headerlink\" title=\"5，Visual Notification（可视化消息提醒）\"></a>5，Visual Notification（可视化消息提醒）</h4><p>不同于js的alert()、confirm()和prompt()方法是同步的。Cordova的alert()、confirm()和prompt()方法是异步的，并且对显示内容有更大的控制权限。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-dialogs</div></pre></td></tr></table></figure>\n<h4 id=\"6，Battery（电池）\"><a href=\"#6，Battery（电池）\" class=\"headerlink\" title=\"6，Battery（电池）\"></a>6，Battery（电池）</h4><p>可以获取电池状态信息。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-battery-status</div></pre></td></tr></table></figure>\n<h4 id=\"7，Accelerometer-加速计\"><a href=\"#7，Accelerometer-加速计\" class=\"headerlink\" title=\"7，Accelerometer(加速计)\"></a>7，Accelerometer(加速计)</h4><p>让应用在三维空间(使用笛卡尔三维坐标系统)中决定设备方向。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-device-motion</div></pre></td></tr></table></figure>\n<h4 id=\"8，Compass-指南针\"><a href=\"#8，Compass-指南针\" class=\"headerlink\" title=\"8，Compass(指南针)\"></a>8，Compass(指南针)</h4><p>可以让开发者读取移动设备的朝向。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-device-orientation</div></pre></td></tr></table></figure>\n<h4 id=\"9，Geolocation-地理定位\"><a href=\"#9，Geolocation-地理定位\" class=\"headerlink\" title=\"9，Geolocation(地理定位)\"></a>9，Geolocation(地理定位)</h4><p>让应用判断设备的物理位置。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-geolocation</div></pre></td></tr></table></figure>\n<h4 id=\"10，Camera-相机\"><a href=\"#10，Camera-相机\" class=\"headerlink\" title=\"10，Camera(相机)\"></a>10，Camera(相机)</h4><p>用相机获取图像。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-camera</div></pre></td></tr></table></figure>\n<h4 id=\"11，Media-Capture-（媒体捕获）\"><a href=\"#11，Media-Capture-（媒体捕获）\" class=\"headerlink\" title=\"11，Media Capture （媒体捕获）\"></a>11，Media Capture （媒体捕获）</h4><p>与Camera API相比，不仅能获取图像，还可以录视频或者录音。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-media-capture</div></pre></td></tr></table></figure>\n<h4 id=\"12，Globalization-全球化\"><a href=\"#12，Globalization-全球化\" class=\"headerlink\" title=\"12，Globalization(全球化)\"></a>12，Globalization(全球化)</h4><p>允许应用查询操作系统的当前设置，判断用户使用的语言。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-globalization</div></pre></td></tr></table></figure>\n<h4 id=\"13，Contacts（联系人）\"><a href=\"#13，Contacts（联系人）\" class=\"headerlink\" title=\"13，Contacts（联系人）\"></a>13，Contacts（联系人）</h4><p>读取联系人列表并在应用中使用联系人数据，或使用应用数据向联系人列表中写新的联系人。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-contacts</div></pre></td></tr></table></figure>\n<h4 id=\"14，Media（播放-记录媒体文件）\"><a href=\"#14，Media（播放-记录媒体文件）\" class=\"headerlink\" title=\"14，Media（播放/记录媒体文件）\"></a>14，Media（播放/记录媒体文件）</h4><p>让应用能记录或播放媒体文件。用它可以在手机后台播放音频文件或玩桌面视频游戏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-media</div></pre></td></tr></table></figure>\n<h4 id=\"15，InAppBrowser（内置浏览器）\"><a href=\"#15，InAppBrowser（内置浏览器）\" class=\"headerlink\" title=\"15，InAppBrowser（内置浏览器）\"></a>15，InAppBrowser（内置浏览器）</h4><p>允许在在单独的窗口中加载网页。例如要向应用用户展示其他网页。当然可以很容易地在应用中加载网页内容并管理，但有时候需要不同的用户体验，InAppBrowser加载网页内容，应用用户可以更方便的直接返回到主应用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-inappbrowser</div></pre></td></tr></table></figure>\n<h4 id=\"16，Splashscreen（闪屏）\"><a href=\"#16，Splashscreen（闪屏）\" class=\"headerlink\" title=\"16，Splashscreen（闪屏）\"></a>16，Splashscreen（闪屏）</h4><p>用来在Cordova应用启动时显示自定义的闪屏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-splashscreen</div></pre></td></tr></table></figure>\n<h4 id=\"17，exitApp（退出应用）\"><a href=\"#17，exitApp（退出应用）\" class=\"headerlink\" title=\"17，exitApp（退出应用）\"></a>17，exitApp（退出应用）</h4><p>让 Android 或者 Windows Phone 8 上的APP关闭退出（iOS系统不支持）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-exitapp</div></pre></td></tr></table></figure>\n<h4 id=\"18，barcodeScanner（条形码-二维码扫描）\"><a href=\"#18，barcodeScanner（条形码-二维码扫描）\" class=\"headerlink\" title=\"18，barcodeScanner（条形码/二维码扫描）\"></a>18，barcodeScanner（条形码/二维码扫描）</h4><p>不仅可以通过摄像头识别二维码/条形码，还能生成二维码。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-barcodescanner</div></pre></td></tr></table></figure>\n<h4 id=\"19，file（文件访问操作类）\"><a href=\"#19，file（文件访问操作类）\" class=\"headerlink\" title=\"19，file（文件访问操作类）\"></a>19，file（文件访问操作类）</h4><p>提供对设备上的文件进行读取和写入的功能支持。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-file</div></pre></td></tr></table></figure>\n<h4 id=\"20，fileTransfer（文件传输）\"><a href=\"#20，fileTransfer（文件传输）\" class=\"headerlink\" title=\"20，fileTransfer（文件传输）\"></a>20，fileTransfer（文件传输）</h4><p>实现文件上传、下载及共享等功能。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">cordova plugin add cordova-plugin-file-transfer</div></pre></td></tr></table></figure>\n","slug":"Cordova概要","updated":"2017-06-27T05:06:34.000Z","comments":true,"link":"","permalink":"http://charlsPrince.com/2017/06/23/Cordova概要/","excerpt":"","categories":[],"tags":[{"name":"混合开发","slug":"混合开发","permalink":"http://charlsPrince.com/tags/混合开发/"},{"name":"Cordova","slug":"Cordova","permalink":"http://charlsPrince.com/tags/Cordova/"}]},{"title":"文章标题","date":"2017-06-23T12:13:28.000Z","path":"2017/06/23/文章标题/","text":"乐骑行","raw":"---\ntitle: 文章标题\ndate: 2017-06-23 20:13:28\ntags:\n---\n\n[乐骑行](/leqixing/index.html)\n\n\n","content":"<p><a href=\"/leqixing/index.html\">乐骑行</a></p>\n","slug":"文章标题","updated":"2017-06-23T14:42:03.000Z","comments":true,"link":"","permalink":"http://charlsPrince.com/2017/06/23/文章标题/","excerpt":"","categories":[],"tags":[]},{"title":"Hello World","date":"2017-06-23T12:02:46.000Z","path":"2017/06/23/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":"---\ntitle: Hello World\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"external\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"external\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"external\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"external\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"external\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo server</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"external\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo generate</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"external\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo deploy</div></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"external\">Deployment</a></p>\n","slug":"hello-world","updated":"2017-06-23T12:02:46.000Z","comments":true,"link":"","permalink":"http://charlsPrince.com/2017/06/23/hello-world/","excerpt":"","categories":[],"tags":[]}]